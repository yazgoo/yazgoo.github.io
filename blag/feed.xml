<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="/blag/feed.xml" rel="self" type="application/atom+xml" /><link href="/blag/" rel="alternate" type="text/html" /><updated>2025-01-08T19:59:51+01:00</updated><id>/blag/feed.xml</id><title type="html">It must be bunnies</title><subtitle>My little blog</subtitle><entry><title type="html">Scala for comprehensions in Ruby</title><link href="/blag/2025/01/08/ruby-for-comprehensions.html" rel="alternate" type="text/html" title="Scala for comprehensions in Ruby" /><published>2025-01-08T00:00:00+01:00</published><updated>2025-01-08T00:00:00+01:00</updated><id>/blag/2025/01/08/ruby-for-comprehensions</id><content type="html" xml:base="/blag/2025/01/08/ruby-for-comprehensions.html"><![CDATA[<h2 id="context-map-and-flatmap">Context: <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code></h2>

<p>Scala is a functional language, so the operators <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> are widely used.</p>

<p>To recap:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">map</code> applies a function to each element of a data structure.</li>
  <li><code class="language-plaintext highlighter-rouge">flatMap</code> applies a function that returns a data structure to each element of a data structure and “flattens” the result.</li>
</ul>

<p>This applies to lists but not only to them.</p>

<h3 id="examples-of-map">Examples of <code class="language-plaintext highlighter-rouge">map</code></h3>

<p>With a list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// result: List(2, 4, 6)</span>
</code></pre></div></div>

<p>With an <code class="language-plaintext highlighter-rouge">Option</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">option</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">option</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// result: Some(2)</span>

<span class="k">val</span> <span class="nv">option</span> <span class="k">=</span> <span class="nc">None</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">option</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// result: None</span>
</code></pre></div></div>

<h3 id="examples-of-flatmap">Examples of <code class="language-plaintext highlighter-rouge">flatMap</code></h3>

<p>With a list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// result: List(1, 2, 2, 4, 3, 6)</span>
</code></pre></div></div>

<p>With an <code class="language-plaintext highlighter-rouge">Either</code> (a type that can hold either a value (Right) or an error (Left)):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">either</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">either</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// result: Right(2)</span>

<span class="k">val</span> <span class="nv">either</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">"error"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nv">either</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// result: Left("error")</span>
</code></pre></div></div>

<h3 id="context-functional-programming">Context: Functional Programming</h3>

<p>In Scala, it is common to chain <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, and <code class="language-plaintext highlighter-rouge">filter</code> to write functional programs.</p>

<p>For example, suppose we want to compute all tuples from 0 to 9 whose sum equals 10:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span> <span class="n">y</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}.</span><span class="py">filter</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">10</span>
<span class="o">}</span>
<span class="c1">// result: Vector((1,9), (2,8), (3,7), (4,6), (5,5), (6,4), (7,3), (8,2), (9,1))</span>
</code></pre></div></div>

<h3 id="for-comprehensions">For Comprehensions</h3>

<p>This can quickly become hard to read. To address this, Scala offers <code class="language-plaintext highlighter-rouge">for comprehensions</code>, which allow for more readable code.</p>

<p>Using a <code class="language-plaintext highlighter-rouge">for comprehension</code>, the previous code becomes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span>
    <span class="n">y</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span> <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">10</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// result: Vector((1,9), (2,8), (3,7), (4,6), (5,5), (6,4), (7,3), (8,2), (9,1))</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;-</code> denotes a generator (a data structure to iterate over).</li>
  <li><code class="language-plaintext highlighter-rouge">if</code> (a guard) filters elements.</li>
  <li><code class="language-plaintext highlighter-rouge">yield</code> returns the result (in this case, a tuple).</li>
</ul>

<p>In practice, <code class="language-plaintext highlighter-rouge">&lt;-</code> is a shortcut for <code class="language-plaintext highlighter-rouge">flatMap</code>.</p>

<p>It is also possible to use <code class="language-plaintext highlighter-rouge">map</code> with the <code class="language-plaintext highlighter-rouge">=</code> operator. For example, to multiply each element of a list by 2 and associate these elements with their double:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// result: List((1,2), (2,4), (3,6))</span>
</code></pre></div></div>

<h2 id="port-to-ruby">Port to Ruby</h2>

<p>To explore whether a Ruby syntax is feasible, I attempted to replicate <code class="language-plaintext highlighter-rouge">for comprehensions</code>.</p>

<p>Here’s the proposed syntax, inspired by Scala while keeping Ruby’s spirit:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">for_c</span><span class="p">(</span>
    <span class="n">gen</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">)</span> <span class="p">},</span>
    <span class="n">gen</span><span class="p">(</span><span class="ss">:y</span><span class="p">,</span> <span class="n">if_c</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">})</span> <span class="p">{</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">)</span> <span class="p">},</span>
<span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">}</span>
<span class="c1"># result: [[1, 9], [2, 8], [3, 7], [4, 6], [5, 5], [6, 4], [7, 3], [8, 2], [9, 1]]</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">for_c</span><span class="p">(</span>
    <span class="n">gen</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">},</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:y</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">}</span>
<span class="c1"># result: [[1, 2], [2, 4], [3, 6]]</span>
</code></pre></div></div>

<p>By reimplementing Scala’s <code class="language-plaintext highlighter-rouge">Either</code>, error handling can be simplified without using exceptions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">validate_username</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">username</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;</span> <span class="mi">8</span>
    <span class="no">Either</span><span class="p">.</span><span class="nf">left</span><span class="p">(</span><span class="s2">"Username is too short (8 characters minimum)"</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Either</span><span class="p">.</span><span class="nf">right</span><span class="p">(</span><span class="n">username</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate_date_of_birth</span><span class="p">(</span><span class="n">dob</span><span class="p">,</span> <span class="n">today</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dob</span><span class="p">.</span><span class="nf">next_year</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">today</span>
    <span class="no">Either</span><span class="p">.</span><span class="nf">left</span><span class="p">(</span><span class="s2">"User must be 18 years old or older"</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Either</span><span class="p">.</span><span class="nf">right</span><span class="p">(</span><span class="n">dob</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate_user</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">dob</span><span class="p">)</span>
  <span class="n">for_c</span><span class="p">(</span>
    <span class="n">gen</span><span class="p">(</span><span class="ss">:username</span><span class="p">)</span> <span class="p">{</span> <span class="n">validate_username</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="p">},</span>
    <span class="n">gen</span><span class="p">(</span><span class="ss">:dob</span><span class="p">)</span> <span class="p">{</span> <span class="n">validate_date_of_birth</span><span class="p">(</span><span class="n">dob</span><span class="p">,</span> <span class="no">Date</span><span class="p">.</span><span class="nf">today</span><span class="p">)</span> <span class="p">},</span>
  <span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">dob</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">validate_user</span><span class="p">(</span><span class="s2">"Bob"</span><span class="p">,</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1"># Left("Username is too short (8 characters minimum)")</span>
<span class="nb">puts</span> <span class="n">validate_user</span><span class="p">(</span><span class="s2">"Bob_12345"</span><span class="p">,</span> <span class="no">Date</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1"># Right(Bob_12345 (1960-03-05))</span>
</code></pre></div></div>

<h2 id="implementation-of-for_c">Implementation of <code class="language-plaintext highlighter-rouge">for_c</code></h2>

<p>Here’s the core implementation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Makes variables declared at each step available in code blocks</span>
<span class="k">def</span> <span class="nf">with_binding_from_hash</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">variables</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
    <span class="n">obj</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="s2">"@</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">obj</span><span class="p">.</span><span class="nf">define_singleton_method</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">instance_variable_get</span><span class="p">(</span><span class="s2">"@</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="n">obj</span><span class="p">.</span><span class="nf">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Interprets code blocks with guards</span>
<span class="k">def</span> <span class="nf">for_comprehension_with_guard</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
  <span class="n">with_binding_from_hash</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">new_env</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">clone</span><span class="p">.</span><span class="nf">merge</span><span class="p">({</span> <span class="n">head</span><span class="p">.</span><span class="nf">name</span> <span class="o">=&gt;</span> <span class="n">value</span> <span class="p">})</span>
    <span class="p">[</span><span class="n">new_env</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">new_env</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
    <span class="n">head</span><span class="p">.</span><span class="nf">guard</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">||</span> <span class="n">with_binding_from_hash</span><span class="p">(</span><span class="n">new_env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">.</span><span class="nf">guard</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Main method</span>
<span class="k">def</span> <span class="nf">for_comprehension</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ranges</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">with_binding_from_hash</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">ranges</span>
    <span class="c1"># If at the end or the next element is a `let`, perform a map; otherwise, flat_map</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">tail</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">||</span> <span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Let</span><span class="p">)</span> <span class="p">?</span> <span class="ss">:map</span> <span class="p">:</span> <span class="ss">:flat_map</span>
    <span class="k">if</span> <span class="n">head</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Gen</span>
      <span class="c1"># For generators, iterate over values</span>
      <span class="n">for_comprehension_with_guard</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">env</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">new_env</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
        <span class="n">for_comprehension</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">new_env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">head</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Let</span>
      <span class="c1"># For `let`, associate the value with the variable</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">with_binding_from_hash</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">)</span>
      <span class="n">new_env</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="nf">clone</span><span class="p">.</span><span class="nf">merge</span><span class="p">({</span> <span class="n">head</span><span class="p">.</span><span class="nf">name</span> <span class="o">=&gt;</span> <span class="n">value</span> <span class="p">})</span>
      <span class="n">for_comprehension</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">new_env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The complete implementation of <code class="language-plaintext highlighter-rouge">for_c</code> is available on <a href="https://gist.github.com/yazgoo/e897b5d31b0fae7bb0b299c6a1225ecd">gist.github.com</a>.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The reader can judge the readability and utility of this syntax. The code is not optimized; it remains an experiment.</p>

<p>I am currently exploring implementing effects (IOs) similar to Haskell/cats-effect/ZIO in Ruby, and this syntax will simplify the code significantly.</p>]]></content><author><name></name></author><category term="ruby" /><category term="scala" /><summary type="html"><![CDATA[Context: map and flatMap]]></summary></entry><entry><title type="html">Presenting youtube-subscriptions</title><link href="/blag/2019/10/15/presenting-youtube-subscriptions.html" rel="alternate" type="text/html" title="Presenting youtube-subscriptions" /><published>2019-10-15T00:00:00+02:00</published><updated>2019-10-15T00:00:00+02:00</updated><id>/blag/2019/10/15/presenting-youtube-subscriptions</id><content type="html" xml:base="/blag/2019/10/15/presenting-youtube-subscriptions.html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/WVZpqXBmB3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p><a href="https://github.com/yazgoo/youtube-subscriptions/">github repo</a></p>]]></content><author><name></name></author><category term="rust" /><category term="youtube" /><category term="terminal" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Creating a looper in shell part 3: multiple layers</title><link href="/blag/2019/02/20/creating-a-looper-in-shell-part-3.html" rel="alternate" type="text/html" title="Creating a looper in shell part 3: multiple layers" /><published>2019-02-20T00:00:00+01:00</published><updated>2019-02-20T00:00:00+01:00</updated><id>/blag/2019/02/20/creating-a-looper-in-shell-part-3</id><content type="html" xml:base="/blag/2019/02/20/creating-a-looper-in-shell-part-3.html"><![CDATA[<h1 id="creating-a-looper-in-shell-part-3-multiple-layers">Creating a looper in shell part 3: multiple layers</h1>

<p>To understand this article better it is advised to have read the <a href="../18/creating-a-looper-in-shell-part-2.html">previous one</a>.</p>

<p>In the <a href="../18/creating-a-looper-in-shell-part-2.html">previous article</a>, we saw how to add a layer to the loop, here was the script behavior:</p>

<p><img src="/blag/images/looper_with_layer_timeline.png" alt="timeline" title="looper with layer timeline" /></p>

<p>This aims at adding multiple layers by pressing any key, and being able to remove last layer by pressing <code class="language-plaintext highlighter-rouge">a</code> (pedal #2).</p>

<p><img src="/blag/images/pedal2.png" alt="timeline" title="looper with multiple layer timeline" /></p>

<h1 id="programming-pedals">programming pedals</h1>

<p>As mentionned earlier, I’m using cheap pedals.</p>

<p>I’m using <a href="https://github.com/rgerganov/footswitch">footswitch</a> to program pedals.</p>

<p>For example, here is how to get one of them to simulate a <code class="language-plaintext highlighter-rouge">a</code> keypress:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> ./footswitch <span class="nt">-k</span> a
</code></pre></div></div>

<p>I’ll be using two pedals, one for adding a layer, one for removing last layer.</p>

<h1 id="lets-add-layers">Let’s add layers</h1>

<p>Here are diffs between <a href="../18/creating-a-looper-in-shell-part-2.html">last version</a> and new one (in red are the old lines and in green the new ones).</p>

<style>
#wrapper {
display: inline-block;
margin-top: 1em;
min-width: 800px;
text-align: left;
}
h2 {
background: #fafafa;
background: -moz-linear-gradient(#fafafa, #eaeaea);
background: -webkit-linear-gradient(#fafafa, #eaeaea);
-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa',endColorstr='#eaeaea')";
border: 1px solid #d8d8d8;
border-bottom: 0;
color: #555;
font: 14px sans-serif;
overflow: hidden;
padding: 10px 6px;
text-shadow: 0 1px 0 white;
margin: 0;
}
.file-diff {
border: 1px solid #d8d8d8;
margin-bottom: 1em;
overflow: auto;
padding: 0.5em 0;
}
.file-diff > div {
width: 100%:
}
pre {
margin: 0;
font-family: "Bitstream Vera Sans Mono", Courier, monospace;
font-size: 12px;
line-height: 1.4em;
text-indent: 0.5em;
}
.file {
color: #aaa;
}
.delete {
background-color: #fdd;
}
.insert {
background-color: #dfd;
}
.info {
color: #a0b;
}
</style>

<p>Let’s modify the input function so that it returns <code class="language-plaintext highlighter-rouge">dd</code> return code
and so that it sets a variable (<code class="language-plaintext highlighter-rouge">key</code> with the key that was pressed):</p>

<div id="wrapper">
<pre class="context"> input() {</pre>
<pre class="context">   stty raw</pre>
<pre class="delete">-  dd bs=1 count=1 2&gt; /dev/null</pre>
<pre class="insert">+  key=$(dd bs=1 count=1 2&gt; /dev/null)</pre>
<pre class="insert">+  rc=$?</pre>
<pre class="insert">+  [ $rc -ne 0 ] &amp;&amp; return $rc</pre>
<pre class="context">   stty -raw</pre>
<pre class="insert">+  return 0</pre>
<pre class="context"> }</pre>
</div>
<div id="wrapper">
</div>

<p>Instead of playing one layer (<code class="language-plaintext highlighter-rouge">layer.wav</code>), we play a bunch of them (<code class="language-plaintext highlighter-rouge">layer1.wav</code>, <code class="language-plaintext highlighter-rouge">layer2.wav</code>, …) based on <code class="language-plaintext highlighter-rouge">$layer_number</code> variable.
Instead of returning one pid, we return a list op PIDs.</p>

<div id="wrapper">
<pre class="context"> input() {</pre>
<pre class="delete">-play_layer() {</pre>
<pre class="delete">-  play_layer_pid=""</pre>
<pre class="delete">-  if [ -e "layer.wav" ]</pre>
<pre class="delete">-  then</pre>
<pre class="delete">-    aplay layer.wav &amp;</pre>
<pre class="delete">-    play_layer_pid=$!</pre>
<pre class="delete">-  fi</pre>
<pre class="insert">+play_layers() {</pre>
<pre class="insert">+  play_layer_pids=""</pre>
<pre class="insert">+  for i in $(seq $layer_number)</pre>
<pre class="insert">+  do</pre>
<pre class="insert">+    aplay layer$i.wav &amp;</pre>
<pre class="insert">+    play_layer_pids="$! $play_layer_pids"</pre>
<pre class="insert">+  done</pre>
<pre class="context"> }</pre>
</div>
<div id="wrapper">
</div>

<p>We change current layer to record name to <code class="language-plaintext highlighter-rouge">layer${layer_number}.wav</code> instead of <code class="language-plaintext highlighter-rouge">layer.wav</code> (after incrementing it):</p>

<div id="wrapper">
<pre class="context"> record_layer() {</pre>
<pre class="context">   record_layer_pid=""</pre>
<pre class="context">   if $(cat should_record_layer)</pre>
<pre class="context">   then</pre>
<pre class="delete">-    arecord -f S16_LE -r 48000 -D hw:1,0 layer.wav &amp;</pre>
<pre class="insert">+    layer_number=$[ $layer_number + 1 ]</pre>
<pre class="insert">+    arecord -f S16_LE -r 48000 -D hw:1,0 layer${layer_number}.wav &amp;</pre>
<pre class="context">     record_layer_pid=$!</pre>
<pre class="context">     echo false &gt; should_record_layer</pre>
<pre class="context">   fi</pre>
<pre class="context"> }</pre>
</div>
<div id="wrapper">
</div>

<p>We add a function to remove the last layer registered if <code class="language-plaintext highlighter-rouge">should_remove_layer</code> file contains <code class="language-plaintext highlighter-rouge">true</code>, by decrementing <code class="language-plaintext highlighter-rouge">$layer_number</code>:</p>

<div id="wrapper">
<pre class="insert">+remove_layer() {</pre>
<pre class="insert">+  record_layer_pid=""</pre>
<pre class="insert">+  if $(cat should_remove_layer)</pre>
<pre class="insert">+  then</pre>
<pre class="insert">+    layer_number=$[ $layer_number - 1 ]</pre>
<pre class="insert">+    echo false &gt; should_remove_layer</pre>
<pre class="insert">+  fi</pre>
<pre class="insert">+}</pre>
<pre class="insert">+</pre>
</div>
<div id="wrapper">
</div>

<p>We initialize <code class="language-plaintext highlighter-rouge">should_remove_layer</code> to false, layer_number to 0, and rename <code class="language-plaintext highlighter-rouge">play_layer</code> to <code class="language-plaintext highlighter-rouge">play_layers</code> and <code class="language-plaintext highlighter-rouge">play_layer_pid</code> to <code class="language-plaintext highlighter-rouge">play_layer_pids</code>:</p>

<div id="wrapper">
<pre class="context"> main_loop() {</pre>
<pre class="context">   echo false &gt; should_record_layer</pre>
<pre class="insert">+  echo false &gt; should_remove_layer</pre>
<pre class="insert">+  layer_number=0</pre>
<pre class="context">   while true</pre>
<pre class="context">   do</pre>
<pre class="delete">-    play_layer</pre>
<pre class="delete">-    record_layer  </pre>
<pre class="insert">+    remove_layer</pre>
<pre class="insert">+    play_layers</pre>
<pre class="insert">+    record_layer</pre>
<pre class="context">     aplay background.wav</pre>
<pre class="context">     [ $? -ne 0 ] &amp;&amp; break</pre>
<pre class="delete">-    [ -n $record_layer_pid ] &amp;&amp; kill $record_layer_pid</pre>
<pre class="delete">-    [ -n $play_layer_pid ] &amp;&amp; kill $play_layer_pid</pre>
<pre class="insert">+    [ -n "$record_layer_pid" ] &amp;&amp; kill $record_layer_pid</pre>
<pre class="insert">+    [ -n "$play_layer_pids" ] &amp;&amp; kill $play_layer_pids</pre>
<pre class="context">   done</pre>
<pre class="context"> }</pre>
</div>
<div id="wrapper">
</div>

<p>Instead of waiting for only one input (since there was only one layer), we wait for multiple input in a loop.
If “a” is pressed, we notify that we <code class="language-plaintext highlighter-rouge">should_remove_layer</code>.
Overwise, we notify that we <code class="language-plaintext highlighter-rouge">should_record_layer</code>:</p>

<div id="wrapper">
<pre class="insert">+input_loop() {</pre>
<pre class="insert">+  while true</pre>
<pre class="insert">+  do</pre>
<pre class="insert">+    input</pre>
<pre class="insert">+    [ "$key" = $'\003' ] &amp;&amp; break</pre>
<pre class="insert">+    if [ "$key" = "a" ]</pre>
<pre class="insert">+    then</pre>
<pre class="insert">+      echo true &gt; should_remove_layer</pre>
<pre class="insert">+    else</pre>
<pre class="insert">+      echo true &gt; should_record_layer</pre>
<pre class="insert">+    fi</pre>
<pre class="insert">+    sleep 1</pre>
<pre class="insert">+  done</pre>
<pre class="insert">+}</pre>
<pre class="insert">+</pre>
<pre class="context"> record_background</pre>
<pre class="context"> main_loop &amp;</pre>
<pre class="context"> main_loop_pid=$!</pre>
<pre class="delete">-input</pre>
<pre class="delete">-echo true &gt; should_record_layer</pre>
<pre class="insert">+input_loop</pre>
<pre class="context"> wait $main_loop_pid</pre>
</div>
<div id="wrapper">
</div>

<h1 id="the-whole-script">The whole script</h1>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

input<span class="o">()</span> <span class="o">{</span>
  <span class="nb">stty </span>raw
  <span class="nv">key</span><span class="o">=</span><span class="si">$(</span><span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1 <span class="nv">count</span><span class="o">=</span>1 2&gt; /dev/null<span class="si">)</span>
  <span class="nv">rc</span><span class="o">=</span><span class="nv">$?</span>
  <span class="o">[</span> <span class="nv">$rc</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">return</span> <span class="nv">$rc</span>
  <span class="nb">stty</span> <span class="nt">-raw</span>
  <span class="k">return </span>0
<span class="o">}</span>

record_background<span class="o">()</span> <span class="o">{</span>
  input
  arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 background.wav &amp;
  <span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>
  <span class="nb">sleep </span>1
  input
  <span class="nb">kill</span> <span class="nv">$pid</span>
<span class="o">}</span>

play_layers<span class="o">()</span> <span class="o">{</span>
  <span class="nv">play_layer_pids</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq</span> <span class="nv">$layer_number</span><span class="si">)</span>
  <span class="k">do
    </span>aplay layer<span class="nv">$i</span>.wav &amp;
    <span class="nv">play_layer_pids</span><span class="o">=</span><span class="s2">"</span><span class="nv">$!</span><span class="s2"> </span><span class="nv">$play_layer_pids</span><span class="s2">"</span>
  <span class="k">done</span>
<span class="o">}</span>

record_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">record_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="si">$(</span><span class="nb">cat </span>should_record_layer<span class="si">)</span>
  <span class="k">then
    </span><span class="nv">layer_number</span><span class="o">=</span><span class="nv">$[</span> <span class="nv">$layer_number</span> + 1 <span class="o">]</span>
    arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 layer<span class="k">${</span><span class="nv">layer_number</span><span class="k">}</span>.wav &amp;
    <span class="nv">record_layer_pid</span><span class="o">=</span><span class="nv">$!</span>
    <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
  <span class="k">fi</span>
<span class="o">}</span>

remove_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">record_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="si">$(</span><span class="nb">cat </span>should_remove_layer<span class="si">)</span>
  <span class="k">then
    </span><span class="nv">layer_number</span><span class="o">=</span><span class="nv">$[</span> <span class="nv">$layer_number</span> - 1 <span class="o">]</span>
    <span class="nb">echo false</span> <span class="o">&gt;</span> should_remove_layer
  <span class="k">fi</span>
<span class="o">}</span>

main_loop<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
  <span class="nb">echo false</span> <span class="o">&gt;</span> should_remove_layer
  <span class="nv">layer_number</span><span class="o">=</span>0
  <span class="k">while </span><span class="nb">true
  </span><span class="k">do
    </span>remove_layer
    play_layers
    record_layer
    aplay background.wav
    <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$record_layer_pid</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$record_layer_pid</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$play_layer_pids</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$play_layer_pids</span>
  <span class="k">done</span>
<span class="o">}</span>

input_loop<span class="o">()</span> <span class="o">{</span>
  <span class="k">while </span><span class="nb">true
  </span><span class="k">do
    </span>input
    <span class="o">[</span> <span class="s2">"</span><span class="nv">$key</span><span class="s2">"</span> <span class="o">=</span> <span class="s1">$'</span><span class="se">\0</span><span class="s1">03'</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break
    </span><span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$key</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"a"</span> <span class="o">]</span>
    <span class="k">then
      </span><span class="nb">echo true</span> <span class="o">&gt;</span> should_remove_layer
    <span class="k">else
      </span><span class="nb">echo true</span> <span class="o">&gt;</span> should_record_layer
    <span class="k">fi
    </span><span class="nb">sleep </span>1
  <span class="k">done</span>
<span class="o">}</span>

record_background
main_loop &amp;
<span class="nv">main_loop_pid</span><span class="o">=</span><span class="nv">$!</span>
input_loop
<span class="nb">wait</span> <span class="nv">$main_loop_pid</span>
</code></pre></div></div>
<h1 id="conclusion">Conclusion</h1>

<p>The whole script is now available <a href="https://github.com/yazgoo/looperish">in its own repo</a>.
Of course, patches are welcome !</p>

<p>I use this script on a daily basis, and there are tons of things that could be polished.
Maybe I’ll rewrite it in some other language :)</p>]]></content><author><name></name></author><category term="shell" /><category term="linux" /><category term="loop" /><summary type="html"><![CDATA[Creating a looper in shell part 3: multiple layers]]></summary></entry><entry><title type="html">Creating a looper in shell part 2: adding a layer</title><link href="/blag/2019/02/18/creating-a-looper-in-shell-part-2.html" rel="alternate" type="text/html" title="Creating a looper in shell part 2: adding a layer" /><published>2019-02-18T00:00:00+01:00</published><updated>2019-02-18T00:00:00+01:00</updated><id>/blag/2019/02/18/creating-a-looper-in-shell-part-2</id><content type="html" xml:base="/blag/2019/02/18/creating-a-looper-in-shell-part-2.html"><![CDATA[<h1 id="what-were-aiming-for">What we’re aiming for</h1>

<p>In the <a href="../12/creating-a-looper-in-shell.html">previous article</a>, we saw how to create a basic looper in shell.</p>

<p>This creates our background sound.</p>

<p>Lets add an “overdub” function, which is a way to add a layer on top of the background,</p>

<p>Here is a diagram showing what we’re aiming for:</p>

<p><img src="/blag/images/looper_with_layer_timeline.png" alt="timeline" title="looper with layer timeline" /></p>

<p>If it’s still not clear, here is a video which explains how to use a looper
pedal from JustinGuitar youtube channel (see 8:10 timecode):</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Gd0NhglZWtw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h1 id="how-well-proceed">how we’ll proceed</h1>

<p>Like in previous part, we’ll record the background in its own wav file (background.wav), based on pedal pushes.
Then we’ll play it in a loop.
On the third push, we’ll record the layer in layer.wav, and play it in subsequent loops, in parallel with background.wav.</p>

<h1 id="ipc">IPC</h1>

<p>Because terminal input can only be done in the foreground, 
We’ll have to capture the overdub pedal push in the foreground, and transfer the push to the main loop running in the background.</p>

<p>To do that, we’ll use a very basic aproach: a text file which will contain false if the pedal was not pushed, and true if the pedal was pushed.</p>

<pre style="line-height:15px;">
 ╭────────────╮             ╭───────────╮             ╭─────────────╮
 │            │   reads     │           │   writes    │             │
 │ main loop  ├────────────&gt;│ text file │&lt;────────────┤ pedal input │
 │            │             │           │             │             │
 ╰────────────╯             ╰───────────╯             ╰─────────────╯
</pre>

<h1 id="lets-do-it">let’s do it</h1>

<p>First, we will start the script by removing files from previous recordings:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm </span>background.wav layer.wav
</code></pre></div></div>

<p>As in previous part, we’ll be using this function to capture key presses.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input() {
  stty raw
  dd bs=1 count=1 2&gt; /dev/null
  stty -raw
}
</code></pre></div></div>

<p>then, let’s record background.wav - this is the same thing as in <a href="../12/creating-a-looper-in-shell.html">previous article</a></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record_background<span class="o">()</span> <span class="o">{</span>
  input
  arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 background.wav &amp;
  <span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>
  <span class="nb">sleep </span>1
  input
  <span class="nb">kill</span> <span class="nv">$pid</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As mentioned earlier, we’ll be using a file named <code class="language-plaintext highlighter-rouge">should_record_layer</code> to notify the main_loop that it should start recording the layer (when it contains <code class="language-plaintext highlighter-rouge">true</code>), and initialize it at <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
</code></pre></div></div>

<h1 id="main-loop">main loop</h1>

<p>then let’s start the main loop</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">while </span><span class="nb">true
  </span><span class="k">do
    </span>play_layer
    record_layer  
    aplay background.wav
    <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$record_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$record_layer_pid</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$play_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$play_layer_pid</span>
  <span class="k">done</span>
</code></pre></div></div>

<p>Let’s have a look at what we do here.</p>

<p>First, if a layer was recorded, we play it in the background, and set a variable with aplay pid:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>play_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">play_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-e</span> <span class="s2">"layer.wav"</span> <span class="o">]</span>
  <span class="k">then
    </span>aplay layer.wav &amp;
    <span class="nv">play_layer_pid</span><span class="o">=</span><span class="nv">$!</span>
  <span class="k">fi</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then, if <code class="language-plaintext highlighter-rouge">should_record_layer</code> file contains <code class="language-plaintext highlighter-rouge">true</code>, we record in the background, and set a variable with arecord pid.
Once arecord is started, we can set <code class="language-plaintext highlighter-rouge">should_record_layer</code> to false.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">record_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="si">$(</span><span class="nb">cat </span>should_record_layer<span class="si">)</span>
  <span class="k">then
    </span>arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 layer.wav &amp;
    <span class="nv">record_layer_pid</span><span class="o">=</span><span class="nv">$!</span>
    <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
  <span class="k">fi</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then we can start playing background.wav:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aplay background.wav
</code></pre></div></div>

<p>When we’re done playing background.wav, we kill arecord (the layer recorder) if it is running.
We also kill aplay (the layer player) if it is running.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$record_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$record_layer_pid</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$play_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$play_layer_pid</span>
</code></pre></div></div>

<h1 id="lets-finish-it">let’s finish it</h1>

<p>Then, we call main_loop in the background, wait for a pedal push, and notify main_loop
via <code class="language-plaintext highlighter-rouge">should_record_layer</code> file.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main_loop &amp;
<span class="nv">main_loop_pid</span><span class="o">=</span><span class="nv">$!</span>
input
<span class="nb">echo true</span> <span class="o">&gt;</span> should_record_layer
</code></pre></div></div>

<p>Finally, we wait for main_loop to stop:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">wait</span> <span class="nv">$main_loop_pid</span>
</code></pre></div></div>

<h1 id="the-whole-script">The whole script</h1>

<p>Here is the whole script</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

input<span class="o">()</span> <span class="o">{</span>
  <span class="nb">stty </span>raw
  <span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1 <span class="nv">count</span><span class="o">=</span>1 2&gt; /dev/null
  <span class="nb">stty</span> <span class="nt">-raw</span>
<span class="o">}</span>

record_background<span class="o">()</span> <span class="o">{</span>
  input
  arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 background.wav &amp;
  <span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>
  <span class="nb">sleep </span>1
  input
  <span class="nb">kill</span> <span class="nv">$pid</span>
<span class="o">}</span>

play_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">play_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-e</span> <span class="s2">"layer.wav"</span> <span class="o">]</span>
  <span class="k">then
    </span>aplay layer.wav &amp;
    <span class="nv">play_layer_pid</span><span class="o">=</span><span class="nv">$!</span>
  <span class="k">fi</span>
<span class="o">}</span>

record_layer<span class="o">()</span> <span class="o">{</span>
  <span class="nv">record_layer_pid</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">if</span> <span class="si">$(</span><span class="nb">cat </span>should_record_layer<span class="si">)</span>
  <span class="k">then
    </span>arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 layer.wav &amp;
    <span class="nv">record_layer_pid</span><span class="o">=</span><span class="nv">$!</span>
    <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
  <span class="k">fi</span>
<span class="o">}</span>

main_loop<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo false</span> <span class="o">&gt;</span> should_record_layer
  <span class="k">while </span><span class="nb">true
  </span><span class="k">do
    </span>play_layer
    record_layer  
    aplay background.wav
    <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$record_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$record_layer_pid</span>
    <span class="o">[</span> <span class="nt">-n</span> <span class="nv">$play_layer_pid</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> <span class="nv">$play_layer_pid</span>
  <span class="k">done</span>
<span class="o">}</span>

<span class="nb">rm </span>background.wav layer.wav
record_background
main_loop &amp;
<span class="nv">main_loop_pid</span><span class="o">=</span><span class="nv">$!</span>
input
<span class="nb">echo true</span> <span class="o">&gt;</span> should_record_layer
<span class="nb">wait</span> <span class="nv">$main_loop_pid</span>
</code></pre></div></div>

<h1 id="to-conclude">to conclude</h1>

<p>With less than 60 lines of shell, we’ve made a software pedal with a layer.</p>

<p>With a cheap USB pedal like this which sends a key press, this script is really nice to use:</p>

<p><img src="/blag/images/pedal.jpg" alt="timeline" title="pedal" /></p>]]></content><author><name></name></author><category term="shell" /><category term="linux" /><category term="loop" /><summary type="html"><![CDATA[What we’re aiming for]]></summary></entry><entry><title type="html">Creating a looper in shell</title><link href="/blag/2019/02/12/creating-a-looper-in-shell.html" rel="alternate" type="text/html" title="Creating a looper in shell" /><published>2019-02-12T00:00:00+01:00</published><updated>2019-02-12T00:00:00+01:00</updated><id>/blag/2019/02/12/creating-a-looper-in-shell</id><content type="html" xml:base="/blag/2019/02/12/creating-a-looper-in-shell.html"><![CDATA[<p>On my free time I like to play the guitar.</p>

<p>I have a descent microphone, and I’d like to be able to loop a part and then play over it.</p>

<p>Here is a script to do just that.</p>

<p>First, let’s create a function which will wait for any key to be pressed:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input<span class="o">()</span> <span class="o">{</span>
	<span class="nb">stty </span>raw
	<span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1 <span class="nv">count</span><span class="o">=</span>1 2&gt; /dev/null
	<span class="nb">stty</span> <span class="nt">-raw</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then let’s call it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input
</code></pre></div></div>

<p>Then let’s start recording.</p>

<p>arecord is configured for my mic (which is on hardware device 1,0).</p>

<p>This also runs the command in the background and keeps its pid:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 out.wav &amp;
<span class="nv">pid</span><span class="o">=</span><span class="nv">$?</span>
</code></pre></div></div>

<p>We wait one second (to avoid double taps to be taken into account),
and wait for a key to be pushed again:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sleep </span>1
input
</code></pre></div></div>

<p>Then we stop arecord via kill:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill</span> <span class="nv">$pid</span>
</code></pre></div></div>

<p>We then can play the recorded file in a loop, 
and break the loop when aplay return code is not 0 (which happens when you it Ctrl+C)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nb">true
</span><span class="k">do
	</span>aplay out.wav
	<span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break
</span><span class="k">done</span>
</code></pre></div></div>

<p>Here is the whole script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

input<span class="o">()</span> <span class="o">{</span>
	<span class="nb">stty </span>raw
	<span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1 <span class="nv">count</span><span class="o">=</span>1 2&gt; /dev/null
	<span class="nb">stty</span> <span class="nt">-raw</span>
<span class="o">}</span>

input
arecord <span class="nt">-f</span> S16_LE <span class="nt">-r</span> 48000 <span class="nt">-D</span> hw:1,0 out.wav &amp;
<span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>
<span class="nb">sleep </span>1
input

<span class="nb">kill</span> <span class="nv">$pid</span>
<span class="k">while </span><span class="nb">true
</span><span class="k">do
	</span>aplay out.wav
	<span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">break
</span><span class="k">done</span>
</code></pre></div></div>

<p>For now I can use an additional keyboard as a poor’s man pedal, here is how to use it:</p>

<ul>
  <li>launch the script</li>
  <li>push a key to start recording</li>
  <li>push a key to stop recording and start playback</li>
  <li>hit Ctrl+C to stop playback</li>
</ul>

<p>I like this script as it is super useful and really simple !</p>]]></content><author><name></name></author><category term="shell" /><category term="linux" /><category term="loop" /><summary type="html"><![CDATA[On my free time I like to play the guitar.]]></summary></entry><entry><title type="html">Writing a remote plugin for neovim in ruby</title><link href="/blag/2018/10/27/writing-a-remote-plugin-for-neovim-in-ruby.html" rel="alternate" type="text/html" title="Writing a remote plugin for neovim in ruby" /><published>2018-10-27T00:00:00+02:00</published><updated>2018-10-27T00:00:00+02:00</updated><id>/blag/2018/10/27/writing-a-remote-plugin-for-neovim-in-ruby</id><content type="html" xml:base="/blag/2018/10/27/writing-a-remote-plugin-for-neovim-in-ruby.html"><![CDATA[<p>One of the features that made me switch to <a href="https://neovim.io/">neovim</a> was that
at the time I was writing a <a href="https://github.com/ensime/ensime-vim">plugin</a> 
for vim and I was surprised that
there was no easy way to do asynchronous calls.</p>

<p>Meaning that if your command was taking too long, it freezed the UI.
A famous example of that is SQL client plugin, 
<a href="https://github.com/vim-scripts/dbext.vim">dbext</a>, which will freeze
vim when your sql request takes too long.</p>

<h1 id="remote-plugins">Remote plugins</h1>

<p>Remote plugins are one of the best features of neovim.
Neovim will spawn a separate process, and communicate with it
via <a href="https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md">msgpack</a> RPC API.</p>

<p>So now plugins can process stuff in the background without vim freezing.</p>

<h1 id="neovim-ruby">neovim-ruby</h1>

<p><a href="https://github.com/neovim/neovim-ruby#neovim-ruby">neovim-ruby README</a> is
well writen and will get you started, you should read it if you’re going
to write a remote plugin.</p>

<h1 id="winds-up-client">winds-up-client</h1>

<p>I like kiteboarding, which depends on wind conditions.
The thing is that its good to always have an eye on these conditions.
There’s a very good website which is called <a href="http://winds-up.com/">winds-up</a></p>

<p>I had already written a <a href="https://rubygems.org/gems/winds-up-client">ruby gem</a> to get a ultrashort report from winds-up, 
here is what it looks like</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>winds-up-client <span class="nt">--lpass</span> <span class="nt">--ultrashort</span>
B3↓S1↘P2↘S13↘V2↘
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lpass</code> option tells the client to log in winds-up.com with lastpass</li>
  <li><code class="language-plaintext highlighter-rouge">ultrashort</code> tells that we want the shortest status report</li>
</ul>

<p>The ultrashort report will contain all your favorite spots (first letter of each spot),
the wind speed (in nautical knots) and the wind direction (an arrow),</p>

<p>For example <code class="language-plaintext highlighter-rouge">S13↘</code> means that my spot ‘S’ has 13 knots comming from north-west.</p>

<h1 id="writing-the-plugin">writing the plugin</h1>

<p>I’m installing it in the same repo as my gem, so that when
it is installed via a plugin manager like vim-plug,
it already has the gem embeded with it.
Here is what it looks like:</p>

<p><a href="https://github.com/yazgoo/winds-up-client/blob/master/rplugin/ruby/winds-up-client.rb">rplugin/ruby/winds-up-client.rb</a></p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'neovim'</span>
<span class="nb">require_relative</span> <span class="s1">'../../lib/winds-up-client'</span>
<span class="no">Neovim</span><span class="p">.</span><span class="nf">plugin</span> <span class="k">do</span> <span class="o">|</span><span class="n">plug</span><span class="o">|</span>
  <span class="n">client</span> <span class="o">=</span> <span class="no">WindsUpClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">lpass: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">ultrashort: </span><span class="kp">true</span><span class="p">)</span>
  <span class="n">last_check</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:WindsUp</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">last_check</span><span class="p">.</span><span class="nf">nil?</span> <span class="ow">or</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span> <span class="o">-</span> <span class="n">last_check</span> <span class="o">&gt;</span> <span class="mi">60</span> 
      <span class="k">begin</span>
        <span class="n">nvim</span><span class="p">.</span><span class="nf">set_var</span> <span class="s2">"windsup"</span><span class="p">,</span> <span class="n">client</span><span class="p">.</span><span class="nf">favorites_spots_text</span><span class="p">.</span><span class="nf">chomp</span>
      <span class="k">rescue</span> <span class="no">Exception</span>
      <span class="k">end</span>
      <span class="n">last_check</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s break it down.</p>

<p>I install it in <code class="language-plaintext highlighter-rouge">rplugin/ruby/winds-up-client.rb</code> which is the path which neovim
uses to load ruby neovim plugin.</p>

<p>I require my ruby library (which is in the same repo):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require_relative</span> <span class="s1">'../../lib/winds-up-client'</span>
</code></pre></div></div>

<p>Within my plugin context, I instantiate my client with 
the same arguments as the command line shown before:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Neovim</span><span class="p">.</span><span class="nf">plugin</span> <span class="k">do</span> <span class="o">|</span><span class="n">plug</span><span class="o">|</span>
  <span class="n">client</span> <span class="o">=</span> <span class="no">WindsUpClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">lpass: </span><span class="kp">true</span><span class="p">,</span> <span class="ss">ultrashort: </span><span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>I declare a variable which will contain the timestamp of the last call to my command.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">last_check</span> <span class="o">=</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>Then I declare my command, which can now be invoked via :WindsUp
It has an <code class="language-plaintext highlighter-rouge">nvim</code> client object to interract with neovim.
I make sure it only gets called every 60 seconds, using last_check variable:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:WindsUp</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">last_check</span><span class="p">.</span><span class="nf">nil?</span> <span class="ow">or</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span> <span class="o">-</span> <span class="n">last_check</span> <span class="o">&gt;</span> <span class="mi">60</span> 
      <span class="c1"># ... do stuff</span>
      <span class="n">last_check</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Then I call my command, and set a neovim variable (<code class="language-plaintext highlighter-rouge">windsup</code>) contents 
with my ultrashort report.</p>

<p><a href="https://www.rubydoc.info/github/neovim/neovim-ruby/master/Neovim/Client">Here</a> 
is more documentation on what you can do with <code class="language-plaintext highlighter-rouge">nvim</code> object</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">nvim</span><span class="p">.</span><span class="nf">set_var</span> <span class="s2">"windsup"</span><span class="p">,</span> <span class="n">client</span><span class="p">.</span><span class="nf">favorites_spots_text</span><span class="p">.</span><span class="nf">chomp</span>
<span class="k">rescue</span> <span class="no">Exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I also catch any exception, because I don’t want my plugin to echo
its errors into vim (which it will do in case of exception).
You should definitely not do that when you’re developing your plugin.</p>

<h1 id="using-it">using it</h1>

<p>I then use it in my <a href="https://github.com/yazgoo/vmux-c98tabbar/blob/master/plugin/vmux-c98tabbar.vim#L9">tabbar</a> vimscript (which is based on a fork of <a href="https://github.com/yazgoo/c98tabbar.vim/tree/master/plugin">c98tabbar.vim</a>), by calling my command</p>

<div class="language-vimscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">exists</span><span class="p">(</span><span class="s2">":WindsUp"</span><span class="p">)</span>
  <span class="p">:</span>WindsUp
<span class="k">endif</span>
</code></pre></div></div>

<p>end then retrieving the <code class="language-plaintext highlighter-rouge">g:windup</code> variable contents to display them.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if exists("g:windsup")
  let l:s .= g:windsup
endif
</code></pre></div></div>

<p>Here is the result:</p>

<p><img src="../../../images/ruby-wuc-bar.png" alt="tabbar" /></p>

<h1 id="conclusion">conclusion</h1>

<p>So here was my very simple plugin, you can have a look at it <a href="https://github.com/yazgoo/winds-up-client#neovim-plugin">here</a>.</p>

<p>As you can see, neovim ruby plugins are really easy to write.</p>

<p>Hope it can help you if you want to write your own plugin !</p>]]></content><author><name></name></author><category term="vim" /><category term="neovim" /><category term="ruby" /><category term="plugin" /><summary type="html"><![CDATA[One of the features that made me switch to neovim was that at the time I was writing a plugin for vim and I was surprised that there was no easy way to do asynchronous calls.]]></summary></entry><entry><title type="html">Monitoring MySQL load with /proc</title><link href="/blag/2018/10/10/monitoring-mysql-load-with-proc.html" rel="alternate" type="text/html" title="Monitoring MySQL load with /proc" /><published>2018-10-10T00:00:00+02:00</published><updated>2018-10-10T00:00:00+02:00</updated><id>/blag/2018/10/10/monitoring-mysql-load-with-proc</id><content type="html" xml:base="/blag/2018/10/10/monitoring-mysql-load-with-proc.html"><![CDATA[<p>On a MySQL server, I launched the following command</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">load</span> <span class="k">data</span> <span class="k">local</span> <span class="n">infile</span> <span class="s1">'/tmp/bar'</span> <span class="k">into</span> <span class="k">table</span> <span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">;</span>
</code></pre></div></div>

<p>The command was running for quite some time, and I was looking for a fast way 
to know its progress,
withouth having to restart it or reload MySQL server changing some option.</p>

<p>The idea is to find how much of <code class="language-plaintext highlighter-rouge">/tmp/bar</code> MySQL has read.</p>

<p>First, lets find mysql PID:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pgrep mysql
1337
</code></pre></div></div>

<p>Then, lets find <code class="language-plaintext highlighter-rouge">/tmp/bar</code> file descriptor in <code class="language-plaintext highlighter-rouge">/proc</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /proc/1337/fd |grep /tmp/bar
total 0
lr-x------. 1 user user 64 Oct 10 21:55 4 -&gt; /tmp/bar
</code></pre></div></div>

<p>This is file descriptor #4.</p>

<p>fdinfo allows to know more about file descriptor #4.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /proc/1337/fdinfo/4
pos:    84443136
flags:  0100000
mnt_id: 650
</code></pre></div></div>

<p>The first line gives us the read position in the file.
We then just have to divide it by the total size of the file:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$[</span><span class="si">$(</span><span class="nb">cat</span> /proc/1337/fdinfo/4|head <span class="nt">-1</span>|sed <span class="s1">'s/.*\t//'</span><span class="si">)</span>00 <span class="se">\</span>
/ <span class="si">$(</span><span class="nb">ls</span> <span class="nt">-nl</span> /tmp/bar | <span class="nb">awk</span> <span class="s1">'{print $5}'</span><span class="si">)</span><span class="o">]</span>%
42%
</code></pre></div></div>

<p>So 42% of the file was processed !</p>]]></content><author><name></name></author><category term="mysql" /><category term="proc" /><category term="linux" /><summary type="html"><![CDATA[On a MySQL server, I launched the following command]]></summary></entry><entry><title type="html">Neovim terminal: one week without tmux</title><link href="/blag/neovim/terminal/multiplexer/tmux/2017/11/29/neovim-one-week-without-tmux.html" rel="alternate" type="text/html" title="Neovim terminal: one week without tmux" /><published>2017-11-29T00:00:00+01:00</published><updated>2017-11-29T00:00:00+01:00</updated><id>/blag/neovim/terminal/multiplexer/tmux/2017/11/29/neovim-one-week-without-tmux</id><content type="html" xml:base="/blag/neovim/terminal/multiplexer/tmux/2017/11/29/neovim-one-week-without-tmux.html"><![CDATA[<p>For a while now there has been a <a href="https://neovim.io/doc/user/nvim_terminal_emulator.html">terminal feature integrated in neovim</a>.</p>

<p><a href="http://vimcasts.org/episodes/neovim-terminal/">There’s a vimcast</a> on it if you want more info.</p>

<p>Vim has buffers, tabs, and splits.
The question I’ve been asking myself is simple:
Is it possible to replace my use of tmux with neovim ?
Here is my feedback, after one week leaving tmux.</p>

<p>Disclaimer:</p>

<ol>
  <li>I am not an advanced vim/neovim user</li>
  <li>Nor do I am an advanced tmux user</li>
</ol>

<h1 id="basic-usage-and-configuration">Basic usage and configuration</h1>

<p>To use the terminal in vim, just type:</p>

<p><code class="language-plaintext highlighter-rouge">:terminal</code></p>

<p>This will replace the current buffer you’re focused on with a terminal emulator.
You can write in the terminal by switching to insert mode.</p>

<p>To leave the emulator, just type <code class="language-plaintext highlighter-rouge">^\^n</code>.</p>

<p>I find it kind of complicated, so I’ve done the following re-mapping based on
<a href="http://www.michaelabrahamsen.com/posts/replace-tmux-with-neovim/">Michael Abrahamsen blogpost</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tnoremap jj &lt;C-\&gt;&lt;C-n&gt;
</code></pre></div></div>

<h1 id="basic-stuff">Basic stuff</h1>

<ul>
  <li>
    <p>To copy paste, the usual <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">p</code> work, I mostly use the <code class="language-plaintext highlighter-rouge">+</code> register.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:resize</code>, <code class="language-plaintext highlighter-rouge">:vertical-resize</code> works, which is awesome.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">^n</code> completion will pick up everything managed by vim, including stuff written in your terminal !</p>
  </li>
</ul>

<h1 id="zooming">Zooming</h1>

<p>tmux has a really nice <a href="https://sanctum.geek.nz/arabesque/zooming-tmux-panes/">zooming feature</a>.
I checked a few solutions to do that with vim.</p>

<ul>
  <li><a href="https://github.com/dhruvasagar/vim-zoom">vim-zoom</a>: kinda works, but your buffer needs to be saved</li>
  <li><a href="https://github.com/regedarek/ZoomWin">ZoomWin</a>:
    <ul>
      <li>When I used it it had a few second lags when zooming</li>
      <li>It did not play well with pandoc and other plugins, I got many errors when zooming/restoring</li>
    </ul>
  </li>
  <li><a href="https://github.com/szw/vim-maximizer">vim-maximizer</a>:
    <ul>
      <li>It is equivalent to doing a resize, so other windows don’t disappear, they are just minimized</li>
      <li>It is fast and simple =&gt; my goto choice</li>
    </ul>
  </li>
</ul>

<h1 id="nesting">Nesting</h1>

<p>There is no protection against running vim in vim:
  It will work, but some escape sequence might not.</p>

<h1 id="detaching">Detaching</h1>

<p>tmux is a terminal multiplexer, but it also supports detaching/attaching
  this is really a usefull feature I’m not ready to lose yet.
  For example, it allows me to upgrade my terminal emulator without loosing my session or to keep a session over SSH.</p>

<p>As mentioned <a href="https://github.com/neovim/neovim/issues/5035#issuecomment-288144900">here</a>,
  let’s use abduco (a detach clone) for that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh
alias vmux="abduco -e '^g' -A nvim-session nvim"
</code></pre></div></div>

<p>When we want to run vim as a terminal multiplexer, we’ll just have to run <code class="language-plaintext highlighter-rouge">vmux</code>.
  Just use <code class="language-plaintext highlighter-rouge">CTRL+g</code> to detach from the session.</p>

<h1 id="controlling-vim-session-from-within-terminal">Controlling vim session from within terminal</h1>

<p>One usual workflow I have is:</p>

<ol>
  <li>open a terminal</li>
  <li>find files in a directory</li>
  <li>open a file in the directory</li>
</ol>

<p>With tmux, I just had to do</p>

<p><code class="language-plaintext highlighter-rouge">$ vim myfile</code></p>

<p>At first, I just copied the name of a file in a buffer, then opened it in my vim session.
But I find it complicated.
What I’d like to do is, from within my terminal, call:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vsplit myfile
$ split myfile
$ e myfile
</code></pre></div></div>

<p>Let’s change our vmux command to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/sh
alias vmux="(abduco -l|grep nvim-session) || rm -f /tmp/vim-server;\
  abduco -e '^g' -A nvim-session nvim --cmd \
    \"let g:server_addr = serverstart('/tmp/vim-server')\""
</code></pre></div></div>

<p>This will create a <code class="language-plaintext highlighter-rouge">/tmp/vim-server</code> file used to comunicate with neovim.</p>

<p>As a command line client to the vim server, 
Let’s create <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/send_command_to_vim_session.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/env python
import neovim
import sys
nvim = neovim.attach('socket', path='/tmp/vim-server')
nvim.command(" ".join(sys.argv[1:]))
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">.bashrc</code> or <code class="language-plaintext highlighter-rouge">.zshrc</code>, let’s declare new commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/sh
alias vmux-send="$HOME/.config/nvim/send_command_to_vim_session.py"
for cmd in split vsplit e tabnew
do
  alias $cmd="vmux-send :$cmd"
done
</code></pre></div></div>

<p>Now in a <code class="language-plaintext highlighter-rouge">:terminal</code> session, we will be able to call split or vsplit command !</p>

<h1 id="cd-with-terminal">cd with terminal</h1>

<p>When in terminal mode, when I change directory (<code class="language-plaintext highlighter-rouge">cd</code>), I would like vim to also change its
working directory (<code class="language-plaintext highlighter-rouge">:cd</code>).
You can do so by adding this in your <code class="language-plaintext highlighter-rouge">.zshrc</code> or <code class="language-plaintext highlighter-rouge">.bashrc</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/sh
function cd() {  
  builtin cd "$@";
  # if the parent process is nvim, do a vim cd 
  (ps -o comm= $PPID | grep nvim &gt; /dev/null) &amp;&amp; vmux-send :cd "$@"
}
export cd
</code></pre></div></div>

<h1 id="whats-next">What’s next</h1>

<p>I loved my tmux status bar, so maybe I will try and find a replacement.
My window managers have their own status bars, so it is not that important to me though.</p>

<p>Currently, my setup only supports one <code class="language-plaintext highlighter-rouge">vmux</code> session, I need to fix that.</p>

<p>Maybe I could create a vim plugin integrating most of the stuff I described in here.</p>

<p>A protection against nesting could be nice.</p>

<p>Finally, I would like to protect vim from closing with a prompt when in <code class="language-plaintext highlighter-rouge">vmux</code> mode.</p>

<h1 id="conclusion">Conclusion</h1>

<p>So far, I’m having fun using neovim instead of tmux.
To me there is currently no obvious reason to switch back to tmux.</p>]]></content><author><name></name></author><category term="neovim" /><category term="terminal" /><category term="multiplexer" /><category term="tmux" /><summary type="html"><![CDATA[For a while now there has been a terminal feature integrated in neovim.]]></summary></entry><entry><title type="html">Consuming fuse_kafka events with logstash</title><link href="/blag/2015/01/15/consuming-fuse-kafka-events-with-logstash.html" rel="alternate" type="text/html" title="Consuming fuse_kafka events with logstash" /><published>2015-01-15T00:00:00+01:00</published><updated>2015-01-15T00:00:00+01:00</updated><id>/blag/2015/01/15/consuming-fuse-kafka-events-with-logstash</id><content type="html" xml:base="/blag/2015/01/15/consuming-fuse-kafka-events-with-logstash.html"><![CDATA[<p><a href="https://github.com/yazgoo/fuse_kafka">fuse_kafka</a> is a project I’ve
been working on for the past months.</p>

<p>Basically, it is a system that captures writes done to specific directories
and sends those to apache kafka.
It aims to facilitate heterongeneous log retrieval.</p>

<p>Once you get logs in <a href="http://kafka.apache.org/">kafka</a>, you may want to be able to put
them into a generic enough log centralization system.</p>

<p>That’s why I wrote a plugin for <a href="http://logstash.net/">logstash</a> which
allows to read logstash events from kafka.</p>

<!-- more -->

<p><img src="/blag/images/logstash_fuse_kafka_logo.png" alt="logstash and fuse_kafka!" title="logstash and fuse_kafka!" /></p>

<h2 id="sample-architecture">Sample architecture</h2>

<p>Here is an example of <code class="language-plaintext highlighter-rouge">fuse_kafka</code> setup</p>

<p><img src="../../../images/fuse_kafka_with_logstash.svg" alt="generic architecture" title="generic architecture" /></p>

<ol>
  <li>fuse_kafka is the log shipper: its role is to retrieve logs from machines and send it to kafka</li>
  <li>kafka acts as the logging event messaging queue it is compouned with:
    <ol>
      <li>usually several kafka messaging broker machines</li>
      <li>usually several zookeeper machines</li>
    </ol>
  </li>
  <li>logstash retrieves logs from kafka and writes them for example to an indexer 
 like elasticsearch</li>
  <li>logs can then be queried via a UI (here kibana)</li>
</ol>

<p>In this article, we’re going to do a fully local setup of this architecture.</p>

<h2 id="getting-stuff">Getting stuff</h2>

<p>Let’s create a working directory</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ mkdir /tmp/tutorial
$ cd /tmp/tutorial
</code></pre></div></div>

<p>Let’s download <a href="http://logstash.net/">logstash</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ wget https://download.elasticsearch.org/logstash/logstash/logstash-1.4.2.tar.gz
$ tar xzf logstash-1.4.2.tar.gz
</code></pre></div></div>

<p>And fuse_kafka:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ git clone https://github.com/yazgoo/fuse_kafka.git
</code></pre></div></div>

<h2 id="starting-fuse_kafka-agent">Starting fuse_kafka agent</h2>

<p>Following fuse_kafka quickstart in
<a href="https://github.com/yazgoo/fuse_kafka/blob/master/README.md">README</a>,
we’ll first build fuse_kafka:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ ./fuse_kafka/build.py
</code></pre></div></div>

<p>Then, we’ll open one terminal and start zookeeper (this will also download kafka):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ ./fuse_kafka/build.py zookeeper_start
</code></pre></div></div>

<p>On another terminal, let’s start kafka:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ ./fuse_kafka/build.py kafka_start
</code></pre></div></div>

<p>Now, we’ll start fuse_kafka shipper:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ cd fuse_kafka
$ src/fuse_kafka.py start
</code></pre></div></div>

<p>Let’s check the shipper is running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ src/fuse_kafka.py status
listening on /tmp/fuse-kafka-test
service is running
</code></pre></div></div>

<h2 id="starting-logstash-agent">Starting logstash agent</h2>

<p>Ok, so from a new terminal, in fuse_kafka directory, let’s launch logstash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ../logstash-1.4.2/bin/logstash -p src/ -f conf/logstash.conf
</code></pre></div></div>

<p>Now, let’s try and write to the directory that fuse_kafka is watching:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "hello, world" &gt; /tmp/fuse-kafka-test/first
</code></pre></div></div>

<p>On logstash terminal, you should get this output
(see <a href="https://github.com/yazgoo/fuse_kafka/blob/master/README.md">README</a>
 for more information on each field):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
{
          "path" =&gt; "/tmp/fuse-kafka-test/first",
           "pid" =&gt; 4682,
           "uid" =&gt; 1000,
           "gid" =&gt; 1000,
      "@message" =&gt; "hello, world\n",
    "@timestamp" =&gt; "2015-01-16T11:45:41.000+01:00",
          "user" =&gt; "yazgoo",
         "group" =&gt; "yazgoo",
       "command" =&gt; "-bash ",
      "@version" =&gt; "0.1.4",
       "@fields" =&gt; {
        "hostname" =&gt; "test"
    },
         "@tags" =&gt; [
        [0] "test"
    ]
}
</code></pre></div></div>

<p>This shows that the whole thing worked as expected:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. fuse_kafka captured the writing done with echo and sent it to kafka
1. logstash read it from kafka
</code></pre></div></div>

<h2 id="under-the-hood">Under the hood</h2>

<h3 id="logstash-configuration">logstash configuration</h3>

<p>Let’s have a look at logstash configuration in <code class="language-plaintext highlighter-rouge">conf/logstash.conf</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
input
{
    kafka
    {
        load =&gt; ["$PWD/kafka_2.8.0-0.8.1.1/libs/**/*.jar"]
        zk_connect =&gt; "localhost"
        group_id =&gt; "logstash"
        topic =&gt; "logs"
        num_threads =&gt; 4
    }
}
output { stdout { codec =&gt; rubydebug } }
</code></pre></div></div>

<p>This is the most basic configuration (see <a href="http://logstash.net/docs/1.4.2/configuration#conditionals">documentation</a> for more information on the syntax).</p>

<p>The output part is writing events to stdout.</p>

<p>In the input part,
we’re reading from a local kafka (<code class="language-plaintext highlighter-rouge">zk_connect</code> is zookeeper address),
    <code class="language-plaintext highlighter-rouge">load</code>ing jars from kafka directory, and reading logs <code class="language-plaintext highlighter-rouge">topic</code>.</p>

<h3 id="kafka-plugin">kafka plugin</h3>

<p>We use <a href="https://github.com/yazgoo/fuse_kafka/blob/master/src/logstash/inputs/kafka.rb">kafka input plugin</a>,
which is available in <code class="language-plaintext highlighter-rouge">src/logstash/inputs/kafka.rb</code></p>

<p>This plugin is based on kafka java consumer, hence the jars we load from
<code class="language-plaintext highlighter-rouge">"$PWD/kafka_2.8.0-0.8.1.1/libs/**/*.jar"</code></p>

<h2 id="using-elasticsearch-and-kibana">Using elasticsearch and kibana</h2>

<p>logstash being so easy to use, we can enable kibana and elastic search,
just by replacing the output line in <code class="language-plaintext highlighter-rouge">conf/logstash.conf</code> with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
output
{
    elasticsearch
    {
        host =&gt; localhost
        embedded =&gt; true
    }
    stdout { codec =&gt; rubydebug }
}
</code></pre></div></div>

<p>So now, let’s launch logstash with elasticsearch and kibana UI in embedded mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>../logstash-1.4.2/bin/logstash -p src/ -f conf/logstash.conf web --port 1234
</code></pre></div></div>

<p>A default UI should be available at 
<a href="http://localhost:1234/index.html#/dashboard/file/guided.json">http://localhost:1234/index.html#/dashboard/file/guided.json</a></p>

<p>On the <code class="language-plaintext highlighter-rouge">DOCUMENTS</code> widget, lets select:</p>

<ul>
  <li>@fields.hostname</li>
  <li>@timestamp</li>
  <li>path</li>
  <li>@message</li>
  <li>command</li>
</ul>

<p>Here is what we get:</p>

<p><img src="/blag/images/kibana.png" alt="kibana screenshot" title="kibana screenshot" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>Logstash/ElasticSearch/Kibana are awesome, and fuse_kafka/kafka 
now can fit right with this power trio!</p>]]></content><author><name></name></author><category term="logstash" /><category term="log centralization" /><category term="fuse_kafka" /><category term="elasticsearch" /><category term="kibana" /><category term="kafka" /><summary type="html"><![CDATA[fuse_kafka is a project I’ve been working on for the past months.]]></summary></entry><entry><title type="html">Output rotation with logstash</title><link href="/blag/2015/01/08/output-rotation-with-logstash.html" rel="alternate" type="text/html" title="Output rotation with logstash" /><published>2015-01-08T00:00:00+01:00</published><updated>2015-01-08T00:00:00+01:00</updated><id>/blag/2015/01/08/output-rotation-with-logstash</id><content type="html" xml:base="/blag/2015/01/08/output-rotation-with-logstash.html"><![CDATA[<p>I love <a href="http://logstash.net/">logstash</a>, it is a really powerfull tool,
and it also leverages jruby so it is really self-contained and portable.</p>

<p>Let’s say you want to use <code class="language-plaintext highlighter-rouge">n</code> different outputs based on current date.
Here is the solution I use.</p>

<!-- more -->

<h2 id="configuration">Configuration</h2>

<p>Lets write logstash <a href="http://logstash.net/docs/1.4.2/configuration">configuration</a>.
First, we’ll be using <a href="http://logstash.net/docs/1.4.2/inputs/stdin">stdin</a>
as input.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
input { stdin { } }
</code></pre></div></div>

<p>Then, lets <a href="http://logstash.net/docs/1.4.2/filters/mutate#add_field">add a field</a> named <code class="language-plaintext highlighter-rouge">t</code> containing the time.
Logstash configuration have a nice feature called
<a href="http://logstash.net/docs/1.4.2/configuration#sprintf">sprintf</a>,
which allows you to set a value based on a field or on a java
<a href="http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html">DateTimeFormat</a>.</p>

<p>Here, I will use the seconds in current minute, but you could, for example
use the day (by replacing <code class="language-plaintext highlighter-rouge">ss</code> with <code class="language-plaintext highlighter-rouge">dd</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
filter
{
        mutate { add_field =&gt; { "t" =&gt; "%{+ss}" } }
}
</code></pre></div></div>

<p>Now, lets write our output (we’ll write on <a href="http://logstash.net/docs/1.4.2/outputs/stdout">stdout</a> for tests purpose) using
<a href="http://logstash.net/docs/1.4.2/configuration#conditionals">conditionals</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
output
{
</code></pre></div></div>

<p>If the time field is even, we will display events with rubydebug codec:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
    if [t] =~ /.*[02468]$/ { stdout { codec =&gt; rubydebug } }
</code></pre></div></div>

<p>If it is odd, we will display events with json codec:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
    if [t] =~ /.*[13579]$/ { stdout { codec =&gt; json } }
</code></pre></div></div>

<p>Let’s close the output bracket:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
}
</code></pre></div></div>

<p>Here is the whole configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
input { stdin { } }
filter
{
        mutate { add_field =&gt; { "t" =&gt; "%{+ss}" } }
}
output
{
    if [t] =~ /.*[02468]$/ { stdout { codec =&gt; rubydebug } }
    if [t] =~ /.*[13579]$/ { stdout { codec =&gt; json } }
}
</code></pre></div></div>

<h2 id="testing-it">Testing it</h2>

<p>Lets run the previous configuration with logstash sending an input.
Here, on an odd second:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ echo blax | ./bin/logstash agent -f /tmp/logstash ; echo
{"message":"blax","@version":"1","@timestamp":"2015-01-09T19:14:15.517Z","host":"machine","t":"15"}
</code></pre></div></div>

<p>Here, on an even second:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!bash
$ echo blax | ./bin/logstash agent -f /tmp/logstash ; echo
{
       "message" =&gt; "blax",
      "@version" =&gt; "1",
    "@timestamp" =&gt; "2015-01-09T19:14:24.232Z",
          "host" =&gt; "machine",
             "t" =&gt; "24"
}
</code></pre></div></div>

<p>##Conclusion##</p>

<p>Here, we chose the output based on the second parity using regexes.</p>

<p>But we may have chosen another criteria, for example,
we might have chosen an output on the two first seconds via this conditional:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!ruby
if [t] in ["01", "02"]
</code></pre></div></div>

<p>We also have chosen the output based on the <code class="language-plaintext highlighter-rouge">@timestamp</code> field, but I wanted to use
an output based on the actual current time, not based on the time associated with an event
(both may differ).</p>]]></content><author><name></name></author><category term="logstash" /><summary type="html"><![CDATA[I love logstash, it is a really powerfull tool, and it also leverages jruby so it is really self-contained and portable.]]></summary></entry></feed>